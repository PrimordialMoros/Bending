/*
 * Copyright 2020-2025 Moros
 *
 * This file is part of Bending.
 *
 * Bending is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Bending is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with Bending. If not, see <https://www.gnu.org/licenses/>.
 */

package me.moros.codegen;

import javax.lang.model.element.Modifier;
import java.io.IOException;
import java.lang.System.Logger.Level;
import java.nio.file.Path;
import java.util.Locale;
import java.util.regex.Pattern;
import java.util.stream.Stream;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.TypeSpec;
import me.moros.codegen.vanilla.Generator;
import net.minecraft.resources.ResourceLocation;

record ApiGenerator(String basePackage, Path output, String version) {
  private static final Pattern ILLEGAL = Pattern.compile("[./]");
  private static final String TWO_SPACES = " ".repeat(2);

  void generate(Generator generator, String subPackage, String typeName) {
    generate(generator, subPackage, typeName + "s", typeName, typeName + "Impl");
  }

  void generate(Generator generator, String subPackage, String name, String typeName, String implName) {
    final String packagePath = basePackage + "." + subPackage;
    ApiClassData data = new ApiClassData(packagePath, name, typeName, implName);
    generate(generator, data);
  }

  private void generate(Generator generator, ApiClassData data) {
    // Define class
    TypeSpec.Builder builder = TypeSpec.interfaceBuilder(data.name())
      // Add @SuppressWarnings("unused")
      .addAnnotation(AnnotationSpec.builder(SuppressWarnings.class).addMember("value", "$S", "unused").build())
      .addJavadoc("Code autogenerated, do not edit! " + version);

    // Add fields
    process(generator)
      .map(fieldData -> fieldData.toSpec(data.typeName(), data.implName()))
      .forEach(builder::addField);

    // Build class
    JavaFile apiFile = JavaFile.builder(data.packagePath(), builder.build())
      .indent(TWO_SPACES)
      .skipJavaLangImports(true)
      .build();

    try {
      apiFile.writeTo(output);
    } catch (IOException e) {
      Generators.LOGGER.log(Level.ERROR, "An error occurred while writing source code to the file system.", e);
    }
  }

  private record ApiClassData(String packagePath, ClassName name, ClassName typeName, ClassName implName) {
    private ApiClassData(String pkg, String name, String typeName, String implName) {
      this(pkg, ClassName.get(pkg, name), ClassName.get(pkg, typeName), ClassName.get(pkg, implName));
    }
  }

  private Stream<FieldData> process(Generator generator) {
    return generator.generate().stream().sorted().map(this::formatKey);
  }

  private FieldData formatKey(ResourceLocation location) {
    final String resourceKey = location.getPath();
    final String constantName = ILLEGAL.matcher(resourceKey).replaceAll("_").toUpperCase(Locale.ROOT);
    return new FieldData(constantName, resourceKey);
  }

  record FieldData(String constantName, String value) {
    private FieldSpec toSpec(ClassName typeName, ClassName implName) {
      return FieldSpec.builder(typeName, constantName())
        .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
        .initializer("$T.get($S)", implName, value())
        .build();
    }
  }
}
